*$debug
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE UNITWD(Q5,T5,N5,WID1,WID2,Q3,T3,N3)
C
C     PURPOSE: THE INPUT TIME SERIES (FLOW PER UNIT WIDTH) TO A REACH
C          IS SCALED BY MULTIPLYING BY THE U/S WIDTH AND DIVIDING
C                BY THE DOWNSTREAM WIDTH, SO IT IS NOW A FLOW PER UNIT
C          WIDTH FOR THE D/S REACH.
C
C RAW 29/5/91 INPUT SERIES IS NOW IN Q5, RESULT IS IN Q3
C ALSO HAVE TO COPY T5 TO T3, N5 TO N3
C
      IMPLICIT NONE ! 30/03/2004 

      INTEGER N5,N3,I
      REAL*8 Q5(N5),Q3(*),WID1,WID2,FAC
      INTEGER*4 T5(N5),T3(*)
C
      N3=N5
      FAC = WID1/WID2
C
      DO 10 I=1,N5
	  T3(I) = T5(I)
10        Q3(I) = Q5(I)*FAC
C
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE ADDTS(Q1,T1,N1,Q2,T2,N2,Q3,T3,N3)
C
C     PURPOSE: ADD TWO TIME SERIES OF INSTANTANEOUS VALUES.
C          ENSURE T1(1)=T2(1) BEFORE CALLING ADDTS.
C     INPUT:   Q1,T1,Q2,T2 = TIME SERIES TO BE ADDED.
C     OUTPUT:  Q3,T3 = OUTPUT TIME SERIES
C          N3 = NUMBER OF DATA IN OUTPUT TIME SERIES.
C
      IMPLICIT NONE  ! 30/03/2004 ITB 
      
      INTEGER N1,N2,N3
      REAL*8 Q1(N1),Q2(N2),Q3(N1+N2),SLOPE
      INTEGER*4 T1(N1),T2(N2),T3(N1+N2),FTIM
C
      INTEGER I,J
C
C SET THE FINISH TIME TO THE LESSER OF T1(N1) AND T2(N2)
C
      FTIM=T1(N1)
      IF (T2(N2) .LT. FTIM) FTIM = T2(N2)
C
      N3=1
      T3(N3)=T1(1)
      Q3(N3)=Q1(1)+Q2(1)
C
      I=2 !INDEX TO ARRAYS Q1,T1
      J=I     !INDEX TO ARRAYS Q2,T2
C CHECK IF FINISH
    1 IF (T3(N3) .GE. FTIM) GOTO 999
      N3=N3+1
C
C CHECK WHICH TIME TO USE AS NEXT OUTPUT
      IF ( T1(I) - T2(J) ) 10,20,30
C
   10 T3(N3)=T1(I)
      SLOPE = (Q2(J)-Q2(J-1))/(T2(J)-T2(J-1))
      Q3(N3) = SLOPE * (T3(N3) - T2(J-1)) + Q2(J-1) + Q1(I)
      I=I+1
      GOTO 1
C
C T1,T2 EQUAL - CHOOSE EITHER ONE
   20 T3(N3)=T1(I)
      Q3(N3)=Q1(I) + Q2(J)
      I=I+1
      J=J+1
      GOTO 1
C
   30 T3(N3)=T2(J)
      SLOPE = (Q1(I) - Q1(I-1))/(T1(I) - T1(I-1))
      Q3(N3) = SLOPE * (T3(N3) - T1(I-1)) + Q1(I-1) + Q2(J)
      J=J+1
      GOTO 1
C
  999 IF (T3(N3) .GT. FTIM) N3=N3-1   !ENSURE T3(N3)<=FTIM
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE COMPTS(Q3,T3,N3,NSTAR,NPT,Q4,T4,N4,CTOL,IERR)
C
C     PURPOSE: COMPRESS TIME SERIES Q3,T3 OF N3 VALUES
C          TO GIVE Q4,T4 OF N4 VALUES
C
C     INPUTS : Q3,T3,N3
C     OUTPUTS: Q4,T4,N4
C          CTOL = COMPRESSION TOLERANCE THAT GIVES THE OUTPUT
C                 SERIES
C          IERR = TO INDICATE IF COMPRESSION RESULTS IS OK
C             CALLING ROUTINE MUST CHECK IERR
C
      IMPLICIT NONE  ! 30/03/2004 ITB 

      INTEGER N3,N4,NSTAR,NPT,IERR,N41,N42
      REAL*8 Q3(N3),Q4(N3),C1,C2,CTOL
      INTEGER*4 T3(N3),T4(N3)
C
      IERR=0
      C1=0.0
      C2=0.5      !INITIAL TOLERANCE LEVEL
C
      CALL COMPRS(C1,Q3,T3,N3,Q4,T4,N41)
      IF (N41 .GT. NSTAR) GOTO 10
	 N4=N41       !N41 GOOD ENOUGH
	 CTOL=C1
	   GOTO 500
C
C COMPRESS WITH A HIGHER TOLERANCE
   10 CALL COMPRS(C2,Q3,T3,N3,Q4,T4,N42)
      IF (N42 .LE. NSTAR) GOTO 20
	   C1=C2
	 N41=N42
	 C2=C2 * 2.
	 GOTO 10
C
C N42 IS FINALLY LESS THAN NSTAR - CHECK IF IT IS GOOD ENOUGH
   20 IF (N42 .GT. (NSTAR-NPT)) THEN
	 N4=N42
	 CTOL=C2
      ELSE
C        TRY TO GET N42 AS CLOSE TO NSTAR AS POSSIBLE
	 CALL MRGFLS(C1,C2,NSTAR,NPT,Q3,T3,N3,N41,N42,
     *            CTOL,Q4,T4,N4,IERR)
      ENDIF
C
  500 CONTINUE
      RETURN
      END
C
C
      SUBROUTINE MRGFLS(A,B,NSTAR,NP,Q3,T3,N3,N41,N42,
     *              CTOL,Q4,T4,N4,IERR)
C
C     PURPOSE: TO FIND AN OPTIMUM COMPRESSION TOLERANCE CTOL WHICH
C     GIVES A TIME SERIES Q4,T4 WITH N4 VALUES SUCH THAT
C              (NSTAR-NP) <= N4 <= NSTAR
C       CALLING ROUTINE HAS TO ENSURE THAT N41 >= NSTAR >= N42
C     CODE IS ADAPTED FROM THE MODIFIED REGULAR FALSI ALGORITHM
C
C     INPUT  : A,B = RANGE OF COMPRESSION TOLERANCE WITHIN WHICH
C             CTOL IS TO BE OBTAINED.
C          N41,N42 = NUMBER OF COMPRESSED VALUES AT TOLERANCE
C                OF A,B RESPECTIVELY
C          NSTAR = MAX NUMBER OF DATA VALUES ACCEPTABLE
C          (NSTAR - NP) = MIN NUMBER OF DATA VALUES ACCEPTABLE
C          Q3,T3 = INPUT TIME SERIES WITH N3 VALUES
C
C     OUTPUT : CTOL  = OPTIMUM TOLERANCE
C          Q4,T4 = OUTPUT TIME SERIES WITH N4 VALUES
C          IERR = 0  NO ERROR
C          IERR = 1  NO OPTIMUM
C
      IMPLICIT NONE ! 30/03/2004 ITB     
     
     
      REAL*8 A,B,W,CTOL,Q3(*),Q4(*)
      INTEGER*4 T3(*),T4(*)
      INTEGER NSTAR,NP,N3,N41,N42,N4,FA,FB,FW
C
      INTEGER ISGNFA,NITER,I,IERR,IPRVFW
C
      FA = NSTAR - N41
      ISGNFA = ISIGN(1,FA)
      FB = NSTAR - N42
C
      W=A
      FW=FA
      NITER=50
      DO 20 I=1,NITER
	  IF ( FW.GE.0 .AND. FW.LE.NP ) THEN   !FW GOOD ENOUGH
	   CTOL=W
	   IERR=0
	     RETURN
	ENDIF
C
C GET NEW W
	W=(FA*B - FB*A)/(FA-FB)
	IPRVFW=ISIGN(1,FW)
	CALL COMPRS(W,Q3,T3,N3,Q4,T4,N4)
	  FW=NSTAR-N4
	IF ( ISGNFA*FW .GT. 0 ) THEN
	     A=W
	   FA=FW
	   IF (FW*IPRVFW .GT. 0) FB=FB/2
	ELSE
	   B=W
	     FB=FW
	   IF (FW*IPRVFW .GT. 0) FA=FA/2
	ENDIF
   20 CONTINUE
C
C AT THIS POINT, NO CONVERGENCE AFTER NITER ITERATION.
      CTOL=W
      IERR=1
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE COMPRS(COMTOL,Q3,T3,N3,Q4,T4,N4)
C
C     PURPOSE: COMPRESS AN INSTANTANEOUS TIME SERIES (Q3,T3)
C          AT COMPRESSSION TOLERANCE COMTOL TO GIVE
C          OUTPUT (Q4,T4).
C
      IMPLICIT NONE  ! 30/03/2004 ITB

      INTEGER N3,N4,IND,I,J
      REAL*8 Q3(N3),Q4(N3),QOUT,COMTOL
      INTEGER*4 T3(N3),T4(N3),TOUT
C
      CALL COMPST(COMTOL)
      I=0     !INDEX TO Q3,T3 ARRAY ELEMENTS
      J=0     !INDEX TO Q4,T4 ARRAY ELEMENTS
C
   10 I=I+1
      IF (I .GT. N3) GOTO 500
	 CALL COMPRD(Q3(I),T3(I),QOUT,TOUT,IND)
	 IF (IND .NE. 0) THEN     !ACCEPT THE OUTPUTS
	    J=J+1
	    T4(J)=TOUT
	      Q4(J)=QOUT
	 ENDIF
      GOTO 10
C
  500 CALL COMPFN(QOUT,TOUT,IND)
      IF (IND .NE. 0) THEN        !PUT OUT LAST VALUE
	 J=J+1
	 T4(J)=TOUT
	 Q4(J)=QOUT
      ENDIF
      N4=J
      RETURN
      END
C
C
      SUBROUTINE COMPST(COMTOL)
C
C     PURPOSE:INITIALISE COMMON /CCOMPR/ USED BY COMPRESSION
C         ROUTINES.
C     INPUT:  COMTOL = COMPRESSION TOLERANCE
C
      IMPLICIT NONE ! 30/03//2004 ITB 

      REAL*8 COMTOL
      REAL*8 RANGE,V0,V1,V2
      INTEGER*4 T0,T1,T2
      INTEGER SCOUNT
C
c      COMMON /CCOMPR/ RANGE,SCOUNT,V0,T0,V1,T1,V2,T2
      COMMON /CCOMPR1/ RANGE,V0,V1,V2
      COMMON /CCOMPR2/ T0,T1,T2,SCOUNT
C
      SCOUNT=0    !NUMBER OF SOURCE VALUES
      RANGE=COMTOL
      RETURN
      END
C
C
      SUBROUTINE COMPFN(QOUT,TOUT,IND)
C
C     PURPOSE:CHECK IF THE LAST VALUE OF INPUT SHOULD BE ACCEPTED
C
      IMPLICIT NONE ! 30/03/2004 ITB 
      
      REAL*8 QOUT
      INTEGER*4 TOUT
      REAL*8 RANGE,V0,V1,V2
      INTEGER*4 T0,T1,T2
      INTEGER SCOUNT,IND
C
c      COMMON /CCOMPR/ RANGE,SCOUNT,V0,T0,V1,T1,V2,T2
      COMMON /CCOMPR1/ RANGE,V0,V1,V2
      COMMON /CCOMPR2/ T0,T1,T2,SCOUNT
C
      IND=0
      IF (SCOUNT .GE. 2) THEN
	 QOUT=V1
	 TOUT=T1
	 IND=1
      ENDIF
      RETURN
      END
C
C
      SUBROUTINE COMPRD(QIN,TIN,QOUT,TOUT,IND)
C
C     PURPOSE:CHECK IF AN INPUT POINT CAN BE DISCARDED.
C         IF IND=1 , QOUT AT TOUT IS RETAINED.
C
      IMPLICIT NONE ! 30/03/2004 ITB 

      REAL*8 QIN,QOUT
      INTEGER*4 TIN,TOUT
      REAL*8 SLOPE,COMRAN,STO,SBO,STN,SBN
      REAL*8 RANGE,V0,V1,V2
      INTEGER*4 T0,T1,T2
      INTEGER SCOUNT,IND
C
c      COMMON /CCOMPR/ RANGE,SCOUNT,V0,T0,V1,T1,V2,T2
      COMMON /CCOMPR1/ RANGE,V0,V1,V2
      COMMON /CCOMPR2/ T0,T1,T2,SCOUNT
C
      SCOUNT=SCOUNT+1         !KEEP COUNT OF INPUTS
      IF (SCOUNT - 2)10,20,30
C
C FIRST POINT
   10 V0=QIN
      T0=TIN
      QOUT=QIN
      TOUT=TIN
      IND=1
      GOTO 60
C
C SECOND POINT
   20 V1=QIN
      T1=TIN
      IND=0
      GOTO 50
C
C THIRD POINT
   30 V2=QIN
      T2=TIN
      SLOPE = (V2 - V0)/(T2 - T0)
      IF ((SLOPE .LT. SBO) .OR. (SLOPE .GT. STO)) GOTO 40
C INSIDE RANGE - DISCARD V1,T1 AND MOVE TO NEXT POINT
      V1=V2
      T1=T2
C NARROW THE RANGE
      COMRAN=RANGE * V1   !RANGE PROPORTIONAL TO DATA
      STN = (V1 + COMRAN - V0)/(T1-T0)    !NEW TOP LINE
      SBN = (V1 - COMRAN - V0)/(T1-T0)    !NEW BOTTOM LINE
      IND=0
      IF (STN .LT. STO) STO = STN
      IF (SBN .GT. SBO) SBO = SBN
      GOTO 60
C OUTSIDE RANGE - SET NEW START POINT FOR FOLLOWING COMPRESSION
   40 V0=V1
      T0=T1
      V1=V2
      T1=T2
      QOUT=V0
      TOUT=T0
      IND=1       !OUTPUT NEW START POINT
C
C COMPUTE COMPRESSION RANGE
   50 COMRAN = RANGE * V1
      STO = (V1 + COMRAN - V0)/(T1-T0)
      SBO = (V1 - COMRAN - V0)/(T1-T0)
C
   60 CONTINUE
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE KINWAV(BIGN,ALPRCH,LENRCH,IT0,Q1,N,
     *					T1,Q3,NN,T_END)
C
C     ROUTINE TO CALCULATE THE PROPAGATION BY KINEMATIC
C     WAVES INCLUDING THE FORMATION AND PROPAGATION OF
C     A KINEMATIC SHOCK.
C
C     INPUTS: BIGN,ALPRCH,LENRCH,IT0,Q1,N, T_END
C     OUTPUTS: T1,Q3,NN, IT0,Q1,N
C
C adapted by Ross Woods 24 July 2003 to be called every timestep
c new code indicated by "RAWv7" in comments
c calling convention has changed
c BIGN,ALPRCH,LENRCH still mean the same things
c IT0,Q1,N are now changed by KINWAV
c on input, IT0,Q1,N are still the list of flows and times that you'd like routed 
c (N is number of flows)
c BUT the IT0(1:N) and Q1(1:N) arrays are only as long as is needed for current timestep
c Q1 flows which have entered AND left in the past are not needed. 
c Q1 flows which will not enter before T_END (end of timestep) are not needed
c you now also pass into kinwav T_END, the time in seconds (same units as IT0) 
c that you want the routing to advance to
c KINWAV returns T1(1:NN),Q3(1:NN),NN the flows which exit the reach this timestep
c and also T1(NN+1), Q3(NN+1), the flow which is next expected exit the reach
c KINWAV ALSO returns IT0(1:N), Q1(1:N) and N, where all of there are different to the 
c values they had on input. On output, these are the flows at the u/s end of the reach 
c which have not exited the reach at time T_END
c
c to recover the prior behaviour of KINWAV, you call KINWAV with IT0,Q1,N containing
c the end time series of inputs, and T_END=IT0(N)
c KINWAV should then return te complete outflow series in T1,Q3,NN, and N = 0
c  
C
      IMPLICIT NONE  ! 30/03/2004 ITB 

	INCLUDE 'tdims_v7.INC'
C
      INTEGER N,NN,I,J,IXB,JXB
      INTEGER*4 MAXINT, NN_T   ! 30/03/2004 ITB 
      
      REAL*8 C(N),T0(N),Q2(N)
      REAL*8 Q1(N),Q3(N)
      REAL*8 K,ALFA,XMX,X,XB,XXB,A1,A2,CM
      REAL*8 BIGN,ALPRCH,LENRCH
      INTEGER*4 IT0(N),T1(N), T_END
cdgt added two lines to check for integer overflow
	real*8 i4max
      REAL*8 CTERM   ! 30/03/2004 ITB 
      
      
      DATA I4MAX/2147000000/
C
CCC   EQUIVALENCE (IT0(1),C(1))
C
C
C     GET THE PARAMETERS
C
      ALFA=BIGN
      K=ALPRCH
      XMX=LENRCH

CRAWv7	NN is number of flow-time points we return as having left the reach this timestep
C	if there are no 'flow points' within the reach, we can't route anything
	NN = 0
	IF (N .EQ. 0) RETURN 

CCC ROSS WAS HERE
      DO 22 I=1,N
   22 T0(I)=IT0(I)
C
C     SET 1ST OUTPUT TIME & FLOW EQUAL TO 1ST INPUT TIME & FLOW
C RPI 28/7/2003      NN=1
C RPI 28/7/2003 removed the next 2 lines as these should now be set up in CALCTS
C      T1(NN)=IT0(1)
C      Q3(NN)=max(Q1(1),0.0) ! RPI 31/05/2002 put in to prevent -ve flows
C
C     CALCULATE THE KINEMATIC WAVE PARAMETERS
C
      DO 30 I=1,N
	 Q2(I)=Q1(I)
	 C(I)=ALFA*K**(1./ALFA)*Q1(I)**((ALFA-1.)/ALFA)
   30 CONTINUE
C
C     CHECK FOR BREAKING
C
	IF (N .EQ. 1) GO TO 80 !RAWv7 no breaking if there is only 1 flow point in the reach

      X=0.
   20 XB=XMX
      DO 12 I=2,N
	 J=I-1
	if(c(i).eq.0..or. c(j).eq.0.) go to 12
		 CTERM=1./C(J)-1./C(I)
	 IF(CTERM .EQ. 0) GO TO 12
c	 IF(C(I) .EQ. C(J))GOTO 12
	 XXB=(T0(I)-T0(J))/(1./C(J)-1./C(I))
	 IF(XXB .LT. X .OR. XXB .GT. XB)GOTO 12
	 XB=XXB
	 IXB=I
   12 CONTINUE
      IF(XB .EQ. XMX)GOTO 80
C     PRINT,' BREAKING AT X =',XB
C
C     GO TO POINT OF BREAKING
C
      JXB=IXB-1
C
C     CALCULATE SHOCK WAVE CELERITY
C
      Q2(JXB)=MAX(Q2(JXB),Q2(IXB))
      Q1(JXB)=MIN(Q1(IXB),Q1(JXB))
      A2=(Q2(JXB)/K)**(1./ALFA)
      A1=(Q1(JXB)/K)**(1./ALFA)
      CM=(Q2(JXB)-Q1(JXB))/(A2-A1)
C
C     RE-NUMBER THE CHARACTERISTICS LINES
C     OMITTING THE LINE THAT HAS MERGED
C
      T0(JXB)=T0(JXB)+XB/C(JXB)-XB/CM
      C(JXB)=CM
      N=N-1
      DO 19 I=IXB,N
      T0(I)=T0(I+1)
      C(I)=C(I+1)
      Q1(I)=Q1(I+1)
   19 Q2(I)=Q2(I+1)
      X=XB
C     PRINT,' AT X = ',XB,' LINES ',JXB,' AND',IXB,' HAVE MERGED'
C     PRINT,' TIMES ARE:'
C     DO 15 I=1,N
C     T=X/C(I)+T0(I)
C     PRINT,I,T,Q1(I),Q2(I)
C15   CONTINUE
      GOTO 20
C
   80 CONTINUE

	NN_T = 0							!RAWv7
	J = 0								!RAWv7

      DO 200 I=1,N
	NN=NN+1
CDGT prevent integer overflow
	T1(NN)=min(XMX/C(I)+T0(I),i4max)
CCC ROSS WAS HERE - RPI 28/7/2003 added the test on NN
	IF (NN.GT.1 .AND. T1(NN) .LE. T1(NN-1)) T1(NN)=T1(NN-1)+1
	Q3(NN)=Q1(I)
C	IF(Q1(I) .EQ. Q2(I))GOTO 200
	IF(Q1(I) .NE. Q2(I))THEN
		NN=NN+1
		T1(NN)=T1(NN-1)+1
		Q3(NN)=Q2(I)
	ENDIF
! RPI 24/2/2004 changed LE to LT to cope with short reaches as otherwise
! no shocks get passed out because T1=T0. Another way to look at this
! might to consider it a rounding problem in the calculation of T1, i.e.,
! there should be a 0.5 added to XMX/C(I)+T0(I)
	IF (T1(NN) .LT. T_END) THEN			!RAWv7 
		NN_T = NN						!RAWv7
	ELSE								!RAWv7
		J = J+1							!RAWv7
		Q1(J) = Q1(I)					!RAWv7
		IT0(J) = T0(I)+0.5				!RAWv7
	ENDIF								!RAWv7

200   CONTINUE
C
	NN = NN_T							!RAWv7
	N = J								!RAWv7

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE INTERP(Q4,T4,N4,Q5,T5,N5,IERR)
C
C     PURPOSE: INTERPOLATE Q4,T4 ONTO TIME T5
C
C     INPUT:   Q4,T4,N4 = INPUT SERIES
C          BEFORE CALLING INTERP, ENSURE THAT
C          T5(N5) <= T4(N4)
C     OUTPUT:  Q5,T5,N5
C
      IMPLICIT NONE  ! 30/03/2004 ITB      
     
      INTEGER N4,N5,NT,IERR,I,K
      REAL*8 Q4(N4),Q5(N5),AREAI,AREAM,AREAK,SUMARE
      REAL*8 Q41,Q42,SLOPE
      INTEGER*4 T4(N4),T5(N5)
C
      IERR=0
C
C CHECK THAT FINISH TIME OF THE OUTPUT IS BEFORE LAST TIME OF INPUT
      IF (T5(N5) .GT. T4(N4)) GOTO 999
C
      NT=1
      K=1
C WE DON'T WANT THIS INITIAL VALUE IN THE OUTPUT ARRAY
C NOTE THAT FUTURE REFERENCES TO Q5 HAVE ITS INDEX DECREASED BY ONE.
C     Q5(NT)=Q4(K)
      I=K
C
    5   CONTINUE
      SUMARE=0.
      NT=NT+1
      IF (NT.GT.N5) GOTO 1000
C
   10 IF (T5(NT) .LE. T4(K)) GOTO 20
	K=K+1
	GOTO 10
C
C AT THIS POINT      T4(K-1) < T5(NT) <= T4(K)
   20 IF (T5(NT-1) .LE. T4(I)) GOTO 25
	 I=I+1
	 GOTO 20
C
C AT THIS POINT      T4(I-1) < T5(NT-1) <= T4(I)
   25 AREAI=0.
      AREAM=0.
      AREAK=0.
C
      IF (T5(NT) .LT. T4(I)) THEN    !SOME AREA WITHIN T4(I-1) - T4(I)
	 SLOPE=(Q4(I) - Q4(I-1))/(T4(I) - T4(I-1))
	 Q41=SLOPE*(T5(NT-1)-T4(I-1)) + Q4(I-1)
	 Q42=SLOPE*(T5(NT)-T4(I-1)) + Q4(I-1)
	 AREAM = 0.5 * (T5(NT) - T5(NT-1)) * (Q41 + Q42)
	   GOTO 60
      ENDIF
C
      IF (T5(NT-1) .LT. T4(I)) THEN   !SOME AREA AT HEAD
	 SLOPE=(Q4(I) - Q4(I-1))/(T4(I)-T4(I-1))
	 Q41 = SLOPE * (T5(NT-1) - T4(I-1)) + Q4(I-1)
	 AREAI = 0.5 * (T4(I)-T5(NT-1)) * (Q41 + Q4(I))
      ENDIF
C
      IF (T4(K-1).LT.T5(NT) .AND. T5(NT).LT.T4(K)) THEN !TAIL AREA
	 SLOPE=(Q4(K) - Q4(K-1))/(T4(K)-T4(K-1))
	 Q42 = SLOPE * (T5(NT) - T4(K-1)) + Q4(K-1)
	 AREAK = 0.5 * (T5(NT) - T4(K-1)) * (Q42 + Q4(K-1))
      ENDIF
C
   50 IF (I .EQ. K) GOTO 60
      IF (I.EQ.(K-1).AND.T4(I).LT.T5(NT).AND.T5(NT).LT.T4(K)) GOTO 60
      AREAM = AREAM + 0.5*(T4(I+1) - T4(I))*(Q4(I) + Q4(I+1))
      I=I+1
      GOTO 50
C
   60 SUMARE = AREAI + AREAM + AREAK
C INDEX OF Q5 CHANGED FROM NT TO NT-1 BECAUSE WE DISCARD FISRT VALUE
      Q5(NT-1)=SUMARE/(T5(NT)-T5(NT-1))
      GOTO 5
C
C ERROR - OUTPUT TIME EXCEEDED THE LAST INPUT TIME T4(N4)
  999 IERR=1
      GOTO 1010
C
 1000 N5=NT-1     !NT WAS INCREMENTED BEFORE EXITING LOOP
C
C********
C THE FOLLOWING LINES ARE INCLUDED TO DISCARD THE 1ST POINT IN
C THE OUTPUT SERIES.  *** MAY HAVE TO BE AMENDED LATER. ***
CC    DO 88 L=1,N5-1
CC       T5(L)=T5(L+1)
CC 88    Q5(L)=Q5(L+1)
      N5=N5-1
C********
C
C
 1010 RETURN
      END
C
C     SUBROUTINE WRSITE(OSITE,QOUT,TOUT,NOUT,INS,LUN,FAC)
C
C     INTEGER NOUT,I,LUN,ONUM,INS
C     INTEGER*4 OSITE,TOUT(NOUT),IDON,IHON,IVALUE
C     REAL*8 QOUT(NOUT),FAC
C
C     ONUM=1
C     IF (INS .EQ. 0) THEN
C        WRITE(LUN,82)OSITE,ONUM
C 82     FORMAT(I10,I8,5X,'HISTOGRAM')
C       ELSE
C        WRITE(LUN,84)OSITE,ONUM
C 84     FORMAT(I10,I8,5X,'INSTANT')
C     ENDIF
C
C     DO 100 I=1,NOUT
C        IVALUE=QOUT(I)*FAC
C        CALL MICDH(IDON,IHON,TOUT(I))
C        WRITE(LUN,105)IVALUE,IDON,IHON
C 105    FORMAT(3I12)
C 100 CONTINUE
C     RETURN
C     END
